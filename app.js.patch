--- a/app.js
+++ b/app.js
@@ -41,6 +41,83 @@
 // ====== CONFIG ======
 const TAGGER_ENDPOINT = "https://mazzgogo-photo-translator.hf.space/";
 const TRANSLATE_ENDPOINT = "https://mazzgogo-photo-translator.hf.space/translate";
+
+
+// --- Hugging Face Spaces: wake / retry (handles "Space is asleep" cold start) ---
+const HEALTH_ENDPOINT = TAGGER_ENDPOINT.replace(/\/$/, "") + "/health";
+const WAKE_MAX_ATTEMPTS = 18;     // ~ up to ~60-90s depending on backoff
+const WAKE_TIMEOUT_MS   = 8000;   // per /health probe
+const TAGGER_TIMEOUT_MS = 45000;  // /tagger can be heavy on cold starts
+
+function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
+
+async function fetchWithTimeout(url, options = {}, timeoutMs = 15000){
+  const ctrl = new AbortController();
+  const t = setTimeout(() => ctrl.abort(), timeoutMs);
+  try{
+    return await fetch(url, { ...options, signal: ctrl.signal, cache: "no-store" });
+  } finally {
+    clearTimeout(t);
+  }
+}
+
+function isTransientStatus(status){
+  return status === 502 || status === 503 || status === 504 || status === 520;
+}
+
+async function fetchJsonWithRetry(url, options, timeoutMs, phaseLabel){
+  let lastErr = null;
+  for (let attempt = 1; attempt <= 6; attempt++){
+    try{
+      const r = await fetchWithTimeout(url, options, timeoutMs);
+      if (!r.ok){
+        if (isTransientStatus(r.status) && attempt < 6){
+          // Likely waking up
+          if (phaseLabel) setStatus(`${phaseLabel}…（サーバー起動中 ${attempt}/6）`);
+          await sleep(700 * attempt + Math.random() * 300);
+          continue;
+        }
+        throw new Error(`http ${r.status}`);
+      }
+      return await r.json();
+    } catch(e){
+      lastErr = e;
+      if (attempt < 6){
+        if (phaseLabel) setStatus(`${phaseLabel}…（再試行 ${attempt}/6）`);
+        await sleep(700 * attempt + Math.random() * 300);
+        continue;
+      }
+    }
+  }
+  throw new Error((phaseLabel ? `${phaseLabel}失敗: ` : "") + (lastErr?.message || lastErr));
+}
+
+// Wake the Space (best-effort). Returns true when /health answers OK.
+async function wakeServer(show = true){
+  if (!TAGGER_ENDPOINT) return false;
+
+  for (let attempt = 1; attempt <= WAKE_MAX_ATTEMPTS; attempt++){
+    try{
+      const r = await fetchWithTimeout(HEALTH_ENDPOINT, { method: "GET" }, WAKE_TIMEOUT_MS);
+      if (r.ok){
+        return true;
+      }
+    } catch(e){
+      // network/CORS while sleeping -> treat as still waking
+    }
+    if (show){
+      const dots = ".".repeat((attempt % 3) + 1);
+      setStatus(`サーバー起動中${dots}（HF Spacesがsleepから復帰中）`);
+    }
+    // gentle exponential backoff
+    const wait = Math.min(5000, 400 + attempt * 350);
+    await sleep(wait);
+  }
+  if (show){
+    setStatus("サーバーに接続できませんでした。HF Spacesがsleep中の場合は、少し待つか Space を一度開いて起こしてください。");
+  }
+  return false;
+}
 
 
 // Image upload settings
@@ -373,16 +450,23 @@
   if (!TAGGER_ENDPOINT){
     throw new Error("TAGGER_ENDPOINT not set");
   }
+
+  // Ensure Space is awake (best-effort). Even if this fails, we still try /tagger with retries.
+  await wakeServer(false);
+
   const blob = await canvasToJpegBlob(shot);
-  const fd = new FormData();
-  fd.append("image", blob, "capture.jpg");
 
   const url = new URL(TAGGER_ENDPOINT.replace(/\/$/, "") + "/tagger");
   url.searchParams.set("topk", String(topk));
 
-  const r = await fetch(url.toString(), { method:"POST", body: fd });
-  if (!r.ok) throw new Error("tagger http " + r.status);
-  const j = await r.json();
+  // FormData should be recreated per attempt.
+  const makeOptions = () => {
+    const fd = new FormData();
+    fd.append("image", blob, "capture.jpg");
+    return { method:"POST", body: fd };
+  };
+
+  const j = await fetchJsonWithRetry(url.toString(), makeOptions(), TAGGER_TIMEOUT_MS, "タグ解析中 / Analyzing");
 
   const tags = (j.tags || []).map(x => ({
     label: x.label_en ?? x.label ?? "",
@@ -393,13 +477,15 @@
 
 async function translateTexts(texts, target){
   if (!TRANSLATE_ENDPOINT) return null;
-  const r = await fetch(TRANSLATE_ENDPOINT, {
+
+  await wakeServer(false);
+
+  const j = await fetchJsonWithRetry(TRANSLATE_ENDPOINT, {
     method:"POST",
     headers:{ "Content-Type":"application/json" },
     body: JSON.stringify({ target, texts })
-  });
-  if (!r.ok) throw new Error("translate http " + r.status);
-  const j = await r.json();
+  }, 25000, "翻訳中 / Translating");
+
   if (j && (j.error || j.detail) && !(j.textsTranslated && j.textsTranslated.length)) {
     return null;
   }
@@ -413,9 +499,10 @@
       return;
     }
     const topk = Number(topkSel.value || 30);
+    await wakeServer(true);
 
     setStatus("タグ解析中… / Working… / Analyzing…");
-    tagsEl.textContent = "解析中… / Working…";
+tagsEl.textContent = "解析中… / Working…";
 
     const tagsEn = await postTags(topk);
     if (!tagsEn.length){
@@ -431,10 +518,14 @@
       setStatus("翻訳API未設定のため英語のみ表示しています（TRANSLATE_ENDPOINTを設定してください） / Translation API not set, showing English only (set TRANSLATE_ENDPOINT).");
     } else {
       setStatus("翻訳中… / Translating…");
-      try{ trJa = await translateTexts(texts, "ja"); }catch(e){ trJa = null; }
-      try{ trZh = await translateTexts(texts, "zh"); }catch(e){ trZh = null; }
-      try{ trKo = await translateTexts(texts, "ko"); }catch(e){ trKo = null; }
-    }
+      // Run 3 translations in parallel to reduce wait time
+      const [jaRes, zhRes, koRes] = await Promise.all([
+        translateTexts(texts, "ja").catch(() => null),
+        translateTexts(texts, "zh").catch(() => null),
+        translateTexts(texts, "ko").catch(() => null),
+      ]);
+      trJa = jaRes; trZh = zhRes; trKo = koRes;
+}
 
     const items = tagsEn.map((t, i) => ({
       en: t.label,
@@ -497,3 +588,7 @@
     }catch(e){}
   }
 });
+
+
+// Best-effort: wake HF Space early so the first analyze is faster
+wakeServer(false);